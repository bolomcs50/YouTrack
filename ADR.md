# Architecture Decisions Record

## ADR 001: Data safety
### Status: Accepted
### Context:
Financial data is sensitive. User data must not be exposed to anyone else.
### Decision:
The app must run on the user's machine, and never upload any data to the server.
### Consequences:
- The app must be able to run offline.
- Additional files generated by the app, such as persistent, personalized category rules, must be stored on the user's machine.

## ADR 002: UI
### Status: Accepted
### Context:
The app must provide a user-friendly, modern UI to display the transactions and derived representations.
The developer team (me) must be able to easily build and maintain the UI, and at the moment React and tailwind are the only frameworks I have experience with.
### Decision:
We will use Tailwind and React to build the UI.
### Consequences:
- The app will be built with Tailwind and React.

## ADR 002.1: Graphs
### Status: Accepted
### Context:
The app must visualize valuable insights through graphs, charts and tables.
Charts must be lightweight and fast, be able to handle large datasets and be compatible with the widest range of browsers.
Data visualization is a well-established field, and there are many libraries and frameworks to choose from, including
- [LightningChartJS](https://lightningchart.com/js-charts/) (Discarded: commercial license without free tier)
- [SciChart](https://www.scichart.com/) (Discarded: free tier has a watermark)
- [Chart.js](https://www.chartjs.org/)
- [ECharts](https://echarts.apache.org/)
- [Recharts](https://recharts.org/en-US/)
- [ApexCharts](https://apexcharts.com/) (Discarded: free tier is limited to basic chart types)
- [Plotly](https://plotly.com/javascript/) (Discarder: looks quite basic)

Criteria for evaluation:
- Performance
- Typescript support
- React integration
- Cost (only free is acceptable)

I used https://awesome.cube.dev to find the best libraries and frameworks for data visualization.
### Decision:
Out of the 3 remaining libraries, Chart.js, ECharts and Recharts, I choose Echarts, purely based on feel of the demos and the extensive list of available charts.

## ADR 004: Performance
### Status: Accepted
### Context:
The app must be fast and responsive, and be able to handle large datasets.Multiple graphs use the same data, categorized in the same way
### Decision:
The data will be loaded into a context provider, where it will be aggregated on import and made available to all components.
### Consequences:
- The computational load will be concentrated right after data import.
- Graph load time will not scale with the number of graphs.


## ADR 005: Categorization
### Status: Accepted
### Context:
The app must be able to categorize expense transactions into categories. The categories can conceptially be organized in a tree structure, with parent categories and child categories. Parent categories represent a higher level of abstraction, and child categories represent a specific instance of the parent category.
As such, atransaction can only be assigned to one category, and that can only be a leaf category.
### Decision:
Because breakdown by category with more than 2 abstraction levels is not useful, we will only use 2 levels of abstraction. The more abstract categories will be referred to as (spending) areas, while the more specific will be called categories proper.
Therefore we do not need an actual tree data structure.
### Consequences:
- The category tree will be instantiated as a list of categories with enum properties.

## ADR 005.1: Persistent, personalized category rules
### Status: Accepted
### Context:
Due to the limited nature of a static category rules dictionary, users must be able to add their own rules to the app, and persist them across sessions.
- One way to do this is to store the rules in the local storage of the browser. This is the simplest solution, but it does not work in incognito mode.
- Another one is to do this with a file that the user can import and export. This enables the user to share the rules across devices. And across incognito sessions.
Having rules that persist across sessions, given that the user can already manage them manually via files, could be confusing. THe user would be effectively managing 2 memories, the file and the local storage, the latter being harder to clear and intuitively manage.
### Decision:
User rules will be stored as json files. 
### Consequences:
- The user can import and export their rules as needed, and even edit them manually.
